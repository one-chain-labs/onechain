# Developer Guide

This document provides a guide for developers who want to connect to OneChain. This guide includes how to get started, and some concepts that are important to understand when working with OneChain.

## Getting Started

To get started with OneChain, this guide will walk you through the process of installing OneChain binaries, and introduce you to some key core concepts of OneChain technology.

### Installing OneChain Binaries

OneChain source code is available on GitHub. You can download the source code and build it yourself, or you can directly build the binaries by cargo. The following steps will guide you through the process of building OneChain binaries.

#### Prerequisites

Before you can build OneChain binaries, you need to have the following prerequisites installed on your machine.

##### Rust and Cargo

The suggested method to install Rust is with `rustup` using cURL.

Some other commands in the installation instructions also require cURL to run. If you can't run the cURL command to install Rust, see the instructions to install cURL for your operating system in the following section before you install Rust.

Use the following command to install Rust and Cargo on macOS or Linux:

```sh
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

For additional installation options, see [Install Rust](https://www.rust-lang.org/tools/install).


OneChain uses the latest version of Cargo to build and manage dependencies. See the [Cargo installation](https://doc.rust-lang.org/cargo/getting-started/installation.html) page on the Rust website for more information.

Use the following command to update Rust with `rustup`:

```sh
$ rustup update stable
```

##### Additional prerequisites by operating system

Select the appropriate tab to view the requirements for your system.

<Tabs groupId="operating-systems">

<TabItem value="linux" label="Linux">

The prerequisites needed for the Linux operating system include:

- cURL
- Rust and Cargo
- Git CLI
- CMake
- GCC
- libssl-dev
- libclang-dev
- libpq-dev (optional)
- build-essential

:::info

The Linux instructions assume a distribution that uses the APT package manager. You might need to adjust the instructions to use other package managers.

:::

Install the prerequisites listed in this section. Use the following command to update `apt-get`:

```sh
$ sudo apt-get updat
```

###### All Linux prerequisites
 
Reference the relevant sections that follow to install each prerequisite individually, or run the following to install them all at once:

###### cURL 

Install cURL with the following command:

```sh
$ sudo apt-get install curl
```

Verify that cURL installed correctly with the following command:

```sh
$ curl --version
```

###### Git CLI

Run the following command to install Git, including the [Git CLI](https://cli.github.com/):

```sh
$ sudo apt-get install git-all
```

For more information, see [Install Git on Linux](https://github.com/git-guides/install-git#install-git-on-linux) on the GitHub website.

###### CMake 

Use the following command to install CMake.

```sh
$ sudo apt-get install cmake
```

To customize the installation, see [Installing CMake](https://cmake.org/install/) on the CMake website.

###### GCC

Use the following command to install the GNU Compiler Collection, `gcc`:

```sh
$ sudo apt-get install gcc
```

###### libssl-dev 

Use the following command to install `libssl-dev`:

```sh
$ sudo apt-get install libssl-dev
```

If the version of Linux you use doesn't support `libssl-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libssl-dev/).

(Optional) If you have OpenSSL you might also need to also install `pkg-config`:

```sh
$ sudo apt-get install pkg-config
```

###### libclang-dev 

Use the following command to install `libclang-dev`:

```sh
$ sudo apt-get install libclang-dev
```

If the version of Linux you use doesn't support `libclang-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libclang-dev/).

###### libpq-dev (optional) 

Use the following command to install `libpq-dev`:

```sh
$ sudo apt-get install libpq-dev
```

If the version of Linux you use doesn't support `libpq-dev`, find an equivalent package for it on the [ROS Index](https://index.ros.org/d/libpq-dev/).

###### build-essential

Use the following command to install `build-essential`:

```sh
$ sudo apt-get install build-essential
```

</TabItem>

<TabItem value="mac" label="macOS">

The prerequisites needed for the macOS operating system include:

- Rust and Cargo
- Homebrew
- cURL
- CMake
- libpq (optional)
- Git CLI
- PostgreSQL

macOS includes a version of cURL you can use to install Homebrew. Use Homebrew to install other tools, including a newer version of cURL.

###### Homebrew

Use the following command to install [Homebrew](https://brew.sh/):

```sh
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
```

:::info

If you used the commands in the [Install using Homebrew](#install-homebrew) section, you do not need to install anything else.

:::

###### All macOS prerequisites

With Homebrew installed, you can install individual prerequisites from the following sections or install them all at once with this command:

###### cURL

Use the following command to update the default [cURL](https://curl.se) on macOS:

```sh
$ brew install curl
```

###### CMake 

Use the following command to install CMake:

```sh
$ brew install cmake
```

To customize the installation, see [Installing CMake](https://cmake.org/install/) on the CMake website.

###### libpq (optional) 

Use the following command to install libpq:
```sh
$ brew install libpq
```

###### Git CLI 

Use the following command to install Git:

```sh
$ brew install git
```

After installing Git, download and install the [Git command line interface](https://git-scm.com/download/).

###### PostgreSQL

Visit the official [PostgreSQL website](https://wiki.postgresql.org/wiki/Main_Page) for instructions on downloading PostgreSQL.

</TabItem>

</Tabs>


#### How to build OneChain binaries

Once you have installed all the prerequisites, you can build OneChain binaries. The simplest and direct way to build OneChain binaries is to use the `cargo` command.

```sh
cargo install --locked --git https://github.com/one-chain-labs/onechain.git one_chain  --features tracing
```

and then you can get the OneChain binary installed in `$HOME/.cargo/bin/one_chain`, you can move it to any directory you want, make sure the directory is in your PATH.

If you want to run a node version of OneChain, you can use the following command to build it:

```sh
cargo install --locked --git https://github.com/one-chain-labs/onechain.git one-node
```

then you can find the binary in `$HOME/.cargo/bin/one-node`. ask the customer service if you really want to run a node.

and, if you want to review the code, you can clone the OneChain repository from GitHub using the following command, then build from the source code:

```sh
git clone https://github.com/one-chain-labs/onechain.git
```

### Connect to OneChain

OneChain has Mainnet, Devnet, and Testnet networks available. You can use one of the test networks, Devnet or Testnet, to experiment with the version of OneChain running on that network.

The OneChain Testnet and Devnet networks consist of several validator nodes to validate each network's transactions. Clients send transactions and read requests via this endpoint: `https://rpc-<NETWORK>.onelabs.cc:443` using [JSON-RPC](/RPC).

You can [request test OCT tokens](#request-test-tokens) through the OneChain [devnet-faucet](https://faucet-devnet.onelabs.cc:443) and [testnet-faucet](https://faucet-testnet.onelabs.cc:443), depending on which network you use. The coins on these networks have no financial value. There is no faucet service for Mainnet.

#### Configure OneChain client

To connect the OneChain client to a network, run the following command:

```sh
one_chain client
```

If you receive the `one_chain-client` help output in the console, you already have a client.yaml file. See [Connect to a custom RPC endpoint](#connect-to-a-custom-rpc-endpoint) to add a new environment alias or to switch the currently active network.

The first time you start Sui client without having a client.yaml file, the console displays the following message:

```
Config file ["<PATH-TO-FILE>/client.yaml"] doesn't exist, do you want to connect to a OneChain Full node server [y/N]?
```

Press **y** and then press **Enter**. The process then requests the RPC server URL:

```
OneChain Full node server URL (Defaults to Testnet if not specified) :
```

Press **Enter** to connect to Sui Testnet. To use a custom RPC server, Devnet, or Mainnet, enter the URL to the correct RPC endpoint and then press **Enter**.

If you enter a URL, the process prompts for an alias for the environment:

```
Environment alias for [<URL-ENTERED>] :
```
Type an alias name and press **Enter**.

```
Select key scheme to generate keypair (0 for ed25519, 1 for secp256k1, 2 for secp256r1):
```

Press **0**, **1**, or **2** to select a key scheme and the press **Enter**.

OneChain returns a message similar to the following (depending on the key scheme you selected) that includes the address and 12-word recovery phrase for the address:

```
Generated new keypair for address with scheme "ed25519" [0xb9c83a8b40d3263c9ba40d551514fbac1f8c12e98a4005a0dac072d3549c2442]
Secret Recovery Phrase : [cap wheat many line human lazy few solid bored proud speed grocery]
```

##### Connect to a custom RPC endpoint

If you previously installed a OneChain client that connected to a OneChain network, or created a local network, you can modify your existing client.yaml file to change the configured RPC endpoint. The `one_chain client` commands that relate to environments read from and write to the client.yaml file.

To check currently available environment aliases, run the following command: 

```sh
$ one_chain client envs
```

The command outputs the available environment aliases, with `(active)` denoting the currently active network.

```sh
╭─────────┬────────────────────────────────────┬────────╮
│ alias   │ url                                │ active │
├─────────┼────────────────────────────────────┼────────┤
│ testnet │ https://rpc-testnet.onelabs.cc:443 │ *      │
╰─────────┴────────────────────────────────────┴────────╯
```

To add a new alias for a custom RPC endpoint, run the following command. Replace values in `<` `>` with values for your installation:

```sh
$ one_chain client new-env --alias <ALIAS> --rpc <RPC-SERVER-URL>
```

To switch the active network, run the following command:

```sh
$ one_chain client switch --env <ALIAS>
```

If you encounter an issue, delete the OneChain configuration directory (`~/.one/one_config`) and reinstall the latest binaries and then retry.

### Get your OneChain address

The OneChain address is unique, similarly to the way a social security number or a personal identification number is unique to one person. However, in OneChain you can create and own multiple addresses, all of which are unique. 

In OneChain, an address is 32 bytes and is often encoded in hexadecimal with a `0x` prefix. For example, this is a valid OneChain address: `0x02a212de6a9dfa3a69e22387acfbafbb1a9e591bd9d636e7895dcfc8de05f331`. You can use a OneChain network explorer to find more information about this address and the objects it owns.

OneChain provides multiple ways to obtain a OneChain address. The following are the two most common. 

#### OneChain Wallet

One of the most straightforward ways to obtain a OneChain address for first-time users is through the OneChain Wallet, you can follow the on-screen instructions to create a new wallet. The wallet will generate a new OneChain address and a secret recovery phrase. Make sure you write down the secret recovery phrase and store it in a safe place.

#### Command line interface

If you are using the OneChain command line interface (CLI) to interact with the OneChain network, you can use the `one_chain client` command to generate a new address. By default, when the OneChain CLI runs for the first time it will prompt you to set up your local wallet, and then it generates one OneChain address and the associated secret recovery phrase. Make sure you write down the secret recovery phrase and store it in a safe place.

To generate a new OneChain address use `one_chain client new-address ed25519`, which specifies the keypair scheme flag to be of type `ed25519`.

For more information, see the [OneChain Client CLI](../../../references/cli/client.mdx) documentation.

To see all the generated addresses in the local wallet on your machine, run `one_chain keytool list`. For more information about the keytool options, see the [OneChain Keytool CLI](../../../references/cli/keytool.mdx) documentation.

:::danger

The private keys associated with the OneChain addresses are stored locally on the machine where the CLI is installed, in the `~/.one/one_config/one.keystore` file. Make sure you do not expose this to anyone, as they can use it to get access to your account.

:::

### Request test tokens

To request test tokens, you can use the OneChain faucet. The faucet is a service that provides free test tokens to users for testing purposes. You can request test tokens for the Devnet and Testnet networks. There is no faucet for OneChain Mainnet...

#### through CLI

If you are using the Devnet or Testnet networks, you can use the [OneChain CLI](../../../references/cli/client.mdx) to request tokens for your address. The `one_chain client faucet` uses the active network and active address that is currently set in the OneChain CLI by default, but you can specify custom data through the following two arguments:

- `--address` argument to provide a specific address (or its alias),
- `--url` argument to provide a custom faucet endpoint.

#### through cURL

Use the following cURL command to request tokens directly from the faucet server:

```
curl --location --request POST 'https://faucet-testnet.onelabs.cc/v1/gas' \
--header 'Content-Type: application/json' \
--data-raw '{
    "FixedAmountRequest": {
        "recipient": "<YOUR ADDRESS>"
    }
}'
```

## Your First dApp

dApp stands for "decentralized application", which is an application that runs on a blockchain or decentralized network instead of a centralized server. Typical dApps do not run solely on the blockchain, but instead are composed of different pieces, like a TypeScript frontend that interacts with code that lives on a blockchain. OneChain needs code written in Move for the pieces of a dApp that live on chain. These pieces are referred to as packages, modules, or smart contracts.

The instructions in this section walk you through writing a basic package, debugging and testing your code, and publishing. You need to follow these instructions in the order they appear to complete the exercise.

You use the `move` OneChain CLI command for some instructions.

To begin, open a terminal or console at the location you plan to store your package. Use the `one_chain move new` command to create an empty Move package with the name `my_first_package`:

```sh
$ one_chain move new my_first_package
```

Running the previous command creates a directory with the name you provide (`my_first_package` in this case). The command populates the new directory with a skeleton Move project that consists of a `sources` directory and a `Move.toml` manifest file. Open the manifest with a text editor to review its contents:

```toml
[package]
name = "my_first_package"
edition = "2024.beta" # edition = "legacy" to use legacy (pre-2024) Move
# license = ""					 # e.g., "MIT", "GPL", "Apache 2.0"
# authors = ["..."]			# e.g., ["Joe Smith (joesmith@noemail.com)", "John Snow (johnsnow@noemail.com)"]

[dependencies]
Sui = { git = "https://github.com/one-chain-labs/onechain.git", subdir = "crates/sui-framework/packages/sui-framework", rev = "main" }

# For remote import, use the `{ git = "...", subdir = "...", rev = "..." }`.
# Revision can be a branch, a tag, and a commit hash.
# MyRemotePackage = { git = "https://some.remote/host.git", subdir = "remote/path", rev = "main" }

# For local dependencies use `local = path`. Path is relative to the package root
# Local = { local = "../path/to" }

# To resolve a version conflict and force a specific version for dependency
# override use `override = true`
# Override = { local = "../conflicting/version", override = true }

[addresses]
my_first_package = "0x0"

# Named addresses will be accessible in Move as `@name`. They're also exported:
# for example, `std = "0x1"` is exported by the Standard Library.
# alice = "0xA11CE"

[dev-dependencies]
# The dev-dependencies section allows overriding dependencies for `--test` and
# `--dev` modes. You can introduce test-only dependencies here.
# Local = { local = "../path/to/dev-build" }

[dev-addresses]
# The dev-addresses section allows overwriting named addresses for the `--test`
# and `--dev` modes.
# alice = "0xB0B"
```

The manifest file contents include available sections of the manifest and comments that provide additional information. In Move, you prepend the hash mark (`#`) to a line to denote a comment.

- **[package]:** Contains metadata for the package. By default, the `one_chain move new` command populates only the `name` value of the metadata. In this case, the example passes `my_first_package` to the command, which becomes the name of the package. You can delete the first `#` of subsequent lines of the `[package]` section to provide values for the other available metadata fields.
- **[dependencies]:** Lists the other packages that your package depends on to run. By default, the `one_chain move new` command lists the `Sui` package on GitHub (Testnet version) as the lone dependency.
- **[addresses]:** Declares named addresses that your package uses. By default, the section includes the package you create with the `one_chain move new` command and an address of `0x0`. This value can be left as-is and indicates that [package addresses are automatically managed](../../../../concepts/sui-move-concepts/packages/automated-address-management) when published and upgraded.
- **[dev-dependencies]:** Includes only comments that describe the section.
- **[dev-addresses]:** Includes only comments that describe the section.

### Defining the package

You have a package now but it doesn't do anything. To make your package useful, you must add logic contained in `.move` source files that define _modules_. The `one_chain move new` command creates a .move file in the `sources` directory that defaults to the same name as your project (`my_first_package.move` in this case). For the purpose of this guide, rename the file to `example.move` and open it with a text editor.

Populate the `example.move` file with the following code:

```move
module my_first_package::example;

// Part 1: These imports are provided by default
// use sui::object::{Self, UID};
// use sui::transfer;
// use sui::tx_context::{Self, TxContext};

// Part 2: struct definitions
public struct Sword has key, store {
    id: UID,
    magic: u64,
    strength: u64,
}

public struct Forge has key {
    id: UID,
    swords_created: u64,
}

// Part 3: Module initializer to be executed when this module is published
fun init(ctx: &mut TxContext) {
    let admin = Forge {
        id: object::new(ctx),
        swords_created: 0,
    };

    // Transfer the forge object to the module/package publisher
    transfer::transfer(admin, ctx.sender());
}

// Part 4: Accessors required to read the struct fields
public fun magic(self: &Sword): u64 {
    self.magic
}

public fun strength(self: &Sword): u64 {
    self.strength
}

public fun swords_created(self: &Forge): u64 {
    self.swords_created
}

// Part 5: Public/entry functions (introduced later in the tutorial)

// Part 6: Tests
```

The comments in the preceding code highlight different parts of a typical Move source file.

- **Part 1: Imports** - Code reuse is a necessity in modern programming. Move supports this concept with `use` aliases that allow your module to refer to types and functions declared in other modules. In this example, the module imports from `object`, `transfer`, and `tx_context` modules, but it does not need to do so explicitly, because the compiler provides these `use` statements by default. These modules are available to the package because the `Move.toml` file defines the Sui dependency (along with the `sui` named address) where they are defined.

- **Part 2: Struct declarations** - Structs define types that a module can create or destroy. Struct definitions can include abilities provided with the `has` keyword. The structs in this example, for instance, have the `key` ability, which indicates that these structs are Sui objects that you can transfer between addresses. The `store` ability on the structs provides the ability to appear in other struct fields and be transferred freely.

- **Part 3: Module initializer** - A special function that is invoked exactly once when the module publishes.

- **Part 4: Accessor functions** - These functions allow the fields of the module's structs to be read from other modules.

After you save the file, you have a complete Move package.


### Building your package

Make sure your terminal or console is in the directory that contains your package (`my_first_package` if you're following along). Use the following command to build your package:

```sh
$ one_chain move build
```

A successful build returns a response similar to the following:

```sh
UPDATING GIT DEPENDENCY https://github.com/one-chain-labs/onechain.git
INCLUDING DEPENDENCY Sui
INCLUDING DEPENDENCY MoveStdlib
BUILDING my_first_package
```

If the build fails, you can use the verbose error messaging in output to troubleshoot and resolve root issues.

Now that you have designed your asset and its accessor functions, it's time to test the package code before publishing.

### Testing a package 

OneChain includes support for the Move testing framework. Using the framework, you can write unit tests that analyze Move code much like test frameworks for other languages, such as the built-in Rust testing framework or the JUnit framework for Java.

An individual Move unit test is encapsulated in a public function that has no parameters, no return values, and has the `#[test]` annotation. The testing framework executes such functions when you call the `one_chain move test` command from the package root (`my_move_package` directory as per the current running example):

```sh
$ one_chain move test
```

If you execute this command for the package created in [Write a Package](./write-package.mdx), you see the following output. Unsurprisingly, the test result has an `OK` status because there are no tests written yet to fail.

```sh
BUILDING Sui
BUILDING MoveStdlib
BUILDING my_first_package
Running Move unit tests
Test result: OK. Total tests: 0; passed: 0; failed: 0
```

To actually test your code, you need to add test functions. Start with adding a basic test function to the `example.move` file, inside the module definition:

```move
#[test]
fun test_sword_create() {
    // Create a dummy TxContext for testing
    let mut ctx = tx_context::dummy();

    // Create a sword
    let sword = Sword {
        id: object::new(&mut ctx),
        magic: 42,
        strength: 7,
    };

    // Check if accessor functions return correct values
    assert!(sword.magic() == 42 && sword.strength() == 7, 1);

}
```

As the code shows, the unit test function (`test_sword_create()`) creates a dummy instance of the `TxContext` struct and assigns it to `ctx`. The function then creates a sword object using `ctx` to create a unique identifier and assigns `42` to the `magic` parameter and `7` to `strength`. Finally, the test calls the `magic` and `strength` accessor functions to verify that they return correct values.

The function passes the dummy context, `ctx`, to the `object::new` function as a mutable reference argument (`&mut`), but passes `sword` to its accessor functions as a read-only reference argument, `&sword`.

Now that you have a test function, run the test command again:

```sh
$ one_chain move test
```

After running the `test` command, however, you get a compilation error instead of a test result:

```sh
error[E06001]: unused value without 'drop'
   ┌─ ./sources/example.move:59:65
   │
 9 │       public struct Sword has key, store {
   │                     ----- To satisfy the constraint, the 'drop' ability would need to be added here
   ·
52 │           let sword = Sword {
   │               ----- The local variable 'sword' still contains a value. The value does not have the 'drop' ability and must be consumed before the function returns
   │ ╭─────────────────────'
53 │ │             id: object::new(&mut ctx),
54 │ │             magic: 42,
55 │ │             strength: 7,
56 │ │         };
   │ ╰─────────' The type 'my_first_package::example::Sword' does not have the ability 'drop'
   · │
59 │           assert!(sword.magic() == 42 && sword.strength() == 7, 1);
   │                                                                   ^ Invalid return
```

The error message contains all the necessary information to debug the code. The faulty code is meant to highlight one of the Move language's safety features.

The `Sword` struct represents a game asset that digitally mimics a real-world item. Obviously, a real sword cannot simply disappear (though it can be explicitly destroyed), but there is no such restriction on a digital one. In fact, this is exactly what's happening in the `test` function - you create an instance of a `Sword` struct that simply disappears at the end of the function call. If you saw something disappear before your eyes, you'd be dumbfounded, too.

One of the solutions (as suggested in the error message), is to add the `drop` ability to the definition of the `Sword` struct, which would allow instances of this struct to disappear (be dropped). The ability to drop a valuable asset is not a desirable asset property in this case, so another solution is needed. Another way to solve this problem is to transfer ownership of the `sword`.

To get the test to work, we will need to use the `transfer` module, which is imported by default. Add the following lines to the end of the test function (after the `assert!` call) to transfer ownership of the `sword` to a freshly created dummy address:

```move
let dummy_address = @0xCAFE;
transfer::public_transfer(sword, dummy_address);
```

Run the test command again. Now the output shows a single successful test has run:

```sh
BUILDING MoveStdlib
BUILDING Sui
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_sword_create
Test result: OK. Total tests: 1; passed: 1; failed: 0
```

:::tip

Use a filter string to run only a matching subset of the unit tests. With a filter string provided, the `sui move test` checks the fully qualified (`<address>::<module_name>::<fn_name>`) name for a match.

:::

Example:

```sh
$ sui move test sword
```

The previous command runs all tests whose name contains `sword`.

You can discover more testing options through:

```sh
$ sui move test -h
```

### Sui-specific testing

The previous testing example uses Move but isn't specific to Sui beyond using some Sui packages, such as `sui::tx_context` and `sui::transfer`. While this style of testing is already useful for writing Move code for Sui, you might also want to test additional Sui-specific features. In particular, a Move call in Sui is encapsulated in a Sui transaction, and you might want to test interactions between different transactions within a single test (for example, one transaction creating an object and the other one transferring it).

Sui-specific testing is supported through the `test_scenario` module that provides Sui-related testing functionality otherwise unavailable in pure Move and its testing framework.

The `test_scenario` module provides a scenario that emulates a series of Sui transactions, each with a potentially different user executing them. A test using this module typically starts the first transaction using the `test_scenario::begin` function. This function takes an address of the user executing the transaction as its argument and returns an instance of the `Scenario` struct representing a scenario.

An instance of the `Scenario` struct contains a per-address object pool emulating Sui object storage, with helper functions provided to manipulate objects in the pool. After the first transaction finishes, subsequent test transactions start with the `test_scenario::next_tx` function. This function takes an instance of the `Scenario` struct representing the current scenario and an address of a user as arguments.

Update your `example.move` file to include a function callable from Sui that implements `sword` creation. With this in place, you can then add a multi-transaction test that uses the `test_scenario` module to test these new capabilities. Put this functions after the accessors (Part 5 in comments).

```move
public fun sword_create(magic: u64, strength: u64, ctx: &mut TxContext): Sword {
    Sword {
        id: object::new(ctx),
        magic: magic,
        strength: strength,
    }
}
```

The code of the new functions uses struct creation and Sui-internal modules (`tx_context`) in a way similar to what you have seen in the previous sections. The important part is for the function to have correct signatures.

With the new function included, add another test function to make sure it behaves as expected.

```move
#[test]
fun test_sword_transactions() {
    use sui::test_scenario;

    // Create test addresses representing users
    let initial_owner = @0xCAFE;
    let final_owner = @0xFACE;

    // First transaction executed by initial owner to create the sword
    let mut scenario = test_scenario::begin(initial_owner);
    {
        // Create the sword and transfer it to the initial owner
        let sword = sword_create(42, 7, scenario.ctx());
        transfer::public_transfer(sword, initial_owner);
    };

    // Second transaction executed by the initial sword owner
    scenario.next_tx(initial_owner);
    {
        // Extract the sword owned by the initial owner
        let sword = scenario.take_from_sender<Sword>();
        // Transfer the sword to the final owner
        transfer::public_transfer(sword, final_owner);
    };

    // Third transaction executed by the final sword owner
    scenario.next_tx(final_owner);
    {
        // Extract the sword owned by the final owner
        let sword = scenario.take_from_sender<Sword>();
        // Verify that the sword has expected properties
        assert!(sword.magic() == 42 && sword.strength() == 7, 1);
        // Return the sword to the object pool (it cannot be simply "dropped")
        scenario.return_to_sender(sword)
    };
    scenario.end();
}
```

There are some details of the new testing function to pay attention to. The first thing the code does is create some addresses that represent users participating in the testing scenario. The test then creates a scenario by starting the first transaction on behalf of the initial sword owner.

The initial owner then executes the second transaction (passed as an argument to the `test_scenario::next_tx` function), who then transfers the `sword` they now own to the final owner. In pure Move there is no notion of Sui storage; consequently, there is no easy way for the emulated Sui transaction to retrieve it from storage. This is where the `test_scenario` module helps - its `take_from_sender` function allows an address-owned object of a given type (`Sword`) executing the current transaction to be available for Move code manipulation. For now, assume that there is only one such object. In this case, the test transfers the object it retrieves from storage to another address.

:::tip

Transaction effects, such as object creation and transfer become visible only after a given transaction completes. For example, if the second transaction in the running example created a `sword` and transferred it to the administrator's address, it would only become available for retrieval from the administrator's address (via `test_scenario`, `take_from_sender`, or `take_from_address` functions) in the third transaction.

:::

The final owner executes the third and final transaction that retrieves the `sword` object from storage and checks if it has the expected properties. Remember, as described in [Testing a package](#testing-a-package), in the pure Move testing scenario, after an object is available in Move code (after creation or retrieval from emulated storage), it cannot simply disappear.

In the pure Move testing function, the function transfers the `sword` object to the fake address to handle the disappearing problem. The `test_scenario` package provides a more elegant solution, however, which is closer to what happens when Move code actually executes in the context of Sui - the package simply returns the `sword` to the object pool using the `test_scenario::return_to_sender` function. For scenarios where returning to the sender is not desirable or if you would like to simply destroy the object, the `test_utils` module also provides the generic `destroy<T>` function, that can be used on any type `T` regardless of its ability. It is advisable to check out other useful functions in the [`test_scenario`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_scenario.move) and [`test_utils`](https://github.com/MystenLabs/sui/blob/main/crates/sui-framework/packages/sui-framework/sources/test/test_utils.move) modules as well.

Run the test command again to see two successful tests for our module:

```sh
BUILDING Sui
BUILDING MoveStdlib
BUILDING my_first_package
Running Move unit tests
[ PASS    ] 0x0::example::test_sword_create
[ PASS    ] 0x0::example::test_sword_transactions
Test result: OK. Total tests: 2; passed: 2; failed: 0
```

### Module initializers

Each module in a package can include a special initializer function that runs at publication time. The goal of an initializer function is to pre-initialize module-specific data (for example, to create singleton objects). The initializer function must have the following properties for it to execute at publication:

- Function name must be `init`.
- The parameter list must end with either a `&mut TxContext` or a `&TxContext` type.
- No return values.
- Private visibility.
- Optionally, the parameter list starts by accepting the module's one-time witness by value. See [One Time Witness](https://move-book.com/programmability/one-time-witness.html) in The Move Book for more information.

For example, the following `init` functions are all valid:

- `fun init(ctx: &TxContext)`
- `fun init(ctx: &mut TxContext)`
- `fun init(otw: EXAMPLE, ctx: &TxContext)`
- `fun init(otw: EXAMPLE, ctx: &mut TxContext)`

While the `sui move` command does not support publishing explicitly, you can still test module initializers using the testing framework by dedicating the first transaction to executing the initializer function.

The `init` function for the module in the running example creates a `Forge` object.

```move
fun init(ctx: &mut TxContext) {
    let admin = Forge {
        id: object::new(ctx),
        swords_created: 0,
    };

    transfer::transfer(admin, ctx.sender());
}
```

The tests you have so far call the `init` function, but the initializer function itself isn't tested to ensure it properly creates a `Forge` object. To test this functionality, add a `new_sword` function to take the forge as a parameter and to update the number of created swords at the end of the function. If this were an actual module, you'd replace the `sword_create` function with `new_sword`. To keep the existing tests from failing, however, we will keep both functions.

```move
public fun new_sword(forge: &mut Forge, magic: u64, strength: u64, ctx: &mut TxContext): Sword {
    forge.swords_created = forge.swords_created + 1;
    Sword {
        id: object::new(ctx),
        magic: magic,
        strength: strength,
    }
}
```

Now, create a function to test the module initialization:

```move
#[test]
fun test_module_init() {
    use sui::test_scenario;

    // Create test addresses representing users
    let admin = @0xAD;
    let initial_owner = @0xCAFE;

    // First transaction to emulate module initialization
    let mut scenario = test_scenario::begin(admin);
    {
        init(scenario.ctx());
    };

    // Second transaction to check if the forge has been created
    // and has initial value of zero swords created
    scenario.next_tx(admin);
    {
        // Extract the Forge object
        let forge = scenario.take_from_sender<Forge>();
        // Verify number of created swords
        assert!(forge.swords_created() == 0, 1);
        // Return the Forge object to the object pool
        scenario.return_to_sender(forge);
    };

    // Third transaction executed by admin to create the sword
    scenario.next_tx(admin);
    {
        let mut forge = scenario.take_from_sender<Forge>();
        // Create the sword and transfer it to the initial owner
        let sword = forge.new_sword(42, 7, scenario.ctx());
        transfer::public_transfer(sword, initial_owner);
        scenario.return_to_sender(forge);
    };
    scenario.end();
}
```

As the new test function shows, the first transaction (explicitly) calls the initializer. The next transaction checks if the `Forge` object has been created and properly initialized. Finally, the admin uses the `Forge` to create a sword and transfer it to the initial owner.

You can refer to the source code for the package (with all the tests and functions properly adjusted) in the [first_package](https://github.com/one-chain-labs/onechain/tree/main/examples/move/first_package/sources/example.move) module in the `sui/examples` directory. You can also use the following toggle to review the complete code.

<details>
<summary>
```move
module my_first_package::example;

// Part 1: These imports are provided by default
// use sui::object::{Self, UID};
// use sui::transfer;
// use sui::tx_context::{Self, TxContext};

// Part 2: struct definitions
public struct Sword has key, store {
		id: UID,
		magic: u64,
		strength: u64,
}

public struct Forge has key {
		id: UID,
		swords_created: u64,
}

// Part 3: Module initializer to be executed when this module is published
fun init(ctx: &mut TxContext) {
		let admin = Forge {
				id: object::new(ctx),
				swords_created: 0,
		};

		// Transfer the forge object to the module/package publisher
		transfer::transfer(admin, ctx.sender());
}

// Part 4: Accessors required to read the struct fields
public fun magic(self: &Sword): u64 {
		self.magic
}

public fun strength(self: &Sword): u64 {
		self.strength
}

public fun swords_created(self: &Forge): u64 {
		self.swords_created
}

// Part 5: Public/entry functions (introduced later in the tutorial)
public fun sword_create(magic: u64, strength: u64, ctx: &mut TxContext): Sword {
		// Create a sword
		Sword {
				id: object::new(ctx),
				magic: magic,
				strength: strength,
		}
}

/// Constructor for creating swords
public fun new_sword(forge: &mut Forge, magic: u64, strength: u64, ctx: &mut TxContext): Sword {
		forge.swords_created = forge.swords_created + 1;
		Sword {
				id: object::new(ctx),
				magic: magic,
				strength: strength,
		}
}
// Part 6: Tests
#[test]
fun test_sword_create() {
		// Create a dummy TxContext for testing
		let mut ctx = tx_context::dummy();

		// Create a sword
		let sword = Sword {
				id: object::new(&mut ctx),
				magic: 42,
				strength: 7,
		};

		// Check if accessor functions return correct values
		assert!(sword.magic() == 42 && sword.strength() == 7, 1);
		// Create a dummy address and transfer the sword
		let dummy_address = @0xCAFE;
		transfer::public_transfer(sword, dummy_address);
}

#[test]
fun test_sword_transactions() {
		use sui::test_scenario;

		// Create test addresses representing users
		let initial_owner = @0xCAFE;
		let final_owner = @0xFACE;

		// First transaction executed by initial owner to create the sword
		let mut scenario = test_scenario::begin(initial_owner);
		{
				// Create the sword and transfer it to the initial owner
				let sword = sword_create(42, 7, scenario.ctx());
				transfer::public_transfer(sword, initial_owner);
		};

		// Second transaction executed by the initial sword owner
		scenario.next_tx(initial_owner);
		{
				// Extract the sword owned by the initial owner
				let sword = scenario.take_from_sender<Sword>();
				// Transfer the sword to the final owner
				transfer::public_transfer(sword, final_owner);
		};

		// Third transaction executed by the final sword owner
		scenario.next_tx(final_owner);
		{
				// Extract the sword owned by the final owner
				let sword = scenario.take_from_sender<Sword>();
				// Verify that the sword has expected properties
				assert!(sword.magic() == 42 && sword.strength() == 7, 1);
				// Return the sword to the object pool (it cannot be simply "dropped")
				scenario.return_to_sender(sword)
		};
		scenario.end();
}

#[test]
fun test_module_init() {
		use sui::test_scenario;

		// Create test addresses representing users
		let admin = @0xAD;
		let initial_owner = @0xCAFE;

		// First transaction to emulate module initialization
		let mut scenario = test_scenario::begin(admin);
		{
				init(scenario.ctx());
		};

		// Second transaction to check if the forge has been created
		// and has initial value of zero swords created
		scenario.next_tx(admin);
		{
				// Extract the Forge object
				let forge = scenario.take_from_sender<Forge>();
				// Verify number of created swords
				assert!(forge.swords_created() == 0, 1);
				// Return the Forge object to the object pool
				scenario.return_to_sender(forge);
		};

		// Third transaction executed by admin to create the sword
		scenario.next_tx(admin);
		{
				let mut forge = scenario.take_from_sender<Forge>();
				// Create the sword and transfer it to the initial owner
				let sword = forge.new_sword(42, 7, scenario.ctx());
				transfer::public_transfer(sword, initial_owner);
				scenario.return_to_sender(forge);
		};
		scenario.end();
}
```
</summary>
</details>
